#+km25
(eval-when (:execute :load-toplevel :compile-toplevel)
  (setq *readtable* *km-readtable*))	; So that the dispatch macro #$ is recognized 

(defvar *pre-sn-ht-l* '(
("co-occurs" (("with") . |co-occurs_with|))
("conceptual" (("part" "of") . |conceptual_part_of|))
("evaluation" (("of") . |evaluation_of|))
("is" (("a") . |is_a|))
("associated" (("with") .    |associated_with|))
("physically" (("related" "to") .       |physically_related_to|))
("branch" (("of") .          |branch_of|))
("connected" (("to") .          |connected_to|))
("consists" (("of") .          |consists_of|))
("contains" (() .          |contains|))
("ingredient" (("of") .          |ingredient_of|))
("interconncts" (() .          |interconncts|))
("part" (("of") .          |part_of|))
("tributary" (("of") .          |tributary_of|))
("functionally" (("related" "to") .          |functionally_related_to|))
("indicates" (() .             |indicates|))
("manifestation" (("of") .             |manifestation_of|))
("result" (("of") .             |result_of|))
("users" (() .             |users|))
("affects" (() .             |affects|))
("complicates" (() .                |complicates|))
("disrupts" (() .                |disrupts|))
("interacts" (("with") .                |interacts_with|))
("manages" (() .                |manages|))
("prevents" (() .                |prevents|))
("treats" (() .                |treats|))
("brings" (("about") .             |brings_about|))
("causes" (() .                |causes|))
("produces" (() .                |produces|))
("conceptually" (("related" "to") .             |conceptually_related_to|))
("conceptual" (("part" "of") .                |conceptual_part_of|))
("degree" (("of") .                |degree_of|))
("derivative" (("of") .                |derivative_of|))
("developmental" (("form" "of") .                |developmental_form_of|))
("diagnoses" (() .                |diagnoses|))
("evaluation" (("of") .                |evaluation_of|))
("issue" (("in") .                |issue_in|))
("measurement" (("of") .                |measurement_of|))
("measures" (() .                |measures|))
("method" (("of") .                |method_of|))
("property" (("of") .                |property_of|))
("assesses" (("effect" "of") .                |assesses_effect_of|))
("occurs" (("in") .             |occurs_in|))
("process" (("of") .                |process_of|))
("performs" (() .             |performs|))
("carries" (("out") .                |carries_out|))
("exhibits" (() .                |exhibits|))
("practices" (() .                |practices|))
("temporally" (("related" "to") .             |temporally_related_to|))
("co-occurs" (("with") .                |co-occurs_with|))
("precedes" (() .                |precedes|))
("spatially" (("related" "to") .       |spatially_related_to|))
("adjacent" (("to") .          |adjacent_to|))
("location" (("of") .          |location_of|))
("surrounds" (() .          |surrounds|))
("traverses" (() .          |traverses|))
;@<99 local: /threec/km> cp scs.txt scs.cl ;finish adding these like usn, so can get 14b&maybe more
("requiring" (() .          |requiring|)) ;can finish others soon
;and a few more:
("aggravated" (("by") .  |aggravated_by|))
("alleviated" (("by") .  |alleviated_by|))
("alone" (("or" "in" "combination" "with") .  |alone_or_in_combination_with|))
("as" (("defined" "by") .  |as_defined_by|))
("associated" (("with") .  |associated_with|))
("caused" (("by") .  |caused_by|))
("causing" (()  .  |causing|))
("characterized" (("by") .  |characterized_by|))
("cleared" (("by") .  |cleared_by|))
("due" (("to") .  |due_to|))
("evidence" (("of") .  |evidence_of|))
("exacerbated" (("by") .  |exacerbated_by|))
("examined" (("for") .  |examined_for|))
("excluding" (() .  |excluding|))
("following" (() .  |following|))
("hematologically" (("proven") .  |hematologically_proven|))
("histologically" (("confirmed") .  |histologically_confirmed|))
("histologically" (("confirmed" "by") .  |histologically_confirmed_by|))
("immediately" (("prior" "to") .  |immediately_prior_to|))
("in" (("combination" "with") .  |in_combination_with|))
("including" (() .  |including|))
("inconsistent" (("with") .  |inconsistent_with|))
;dups disregared for now
("other" (("than") .  |other_than|))
("proven" (("by") .  |proven_by|))
("related" (("to") .  |related_to|))
("requiring" (() .  |requiring|))
("secondary" (("to") .  |secondary_to|))
("similar" (("pattern" "of") .  |similar_pattern_of|))
("treated" (("with") .  |treated_with|))
))
;note: collect-if #'nop mapcar == remove-nils on mapcar ;make a collect ;prob a macro, try fnc
;(defun collect (fnc lst)  ;in utl now
;  (collect-if #'nop (mapcar fnc lst)))
(defparameter *sn-ht* (make-hash-table :test #'equal))
(mapcar #'(lambda (le) (setf (gethash (first le) *sn-ht*) (rest le)))  *pre-sn-ht-l*)
(defun snwp (w) (gethash w *sn-ht*))
(defun snwp1 (w) (let ((h (snwp w))) (when h (first h))))
(defun snwp2 (w) (let ((h (snwp w))) (when h (cons w h))))
(defun snrw (w)  ;yes acess from list above
  (let ((hl (snwp1 w)))
    (when hl (first hl))))
(defun snsn (w)  ;yes acess from list above
  (let ((hl (snwp1 w)))
    (when hl (cdr hl))))
(defun snnw (cn wl)
  "see if next in wl is in next words in cons"  ;now that know it's there could find from lst above
  (let* ((word (car cn))  ;but have it in cons sent in now anyway
	; (r (cdr cn))
	;;(r2 (first cn))
	; (rw (first r))
	 (rw (snrw word)))
    ;(format t "~&~a in ~a from ~a" word rw r)
    (format t "~&~a in ~a" word rw)
    (if (null rw) (snsn word) ;(cdr r) ;word ;if no rest-words, that word is the relation
      (let ((nw (get1+ word wl)))  ;~assuming only 1 occur of w in wl, &w/memb not even next
	(when (and nw rw (member nw rw :test #'equal)) (snsn word))))))
;starting2use structure that might be better in an obj ;still like tree/cbr'match' idea;4ease
;  go w/only matching2 now, as won't get the few3in a row often, &last prep not fully important
(defun sn-p (wl) ;so can have position, should of just done search, but no HT(speed)then
 (let* ((hl (collect #'snwp2 wl))  ;just get 1st hit now
	(hl2 (collect #'(lambda (cn) (snnw cn wl)) hl)))
 hl2))
;-
(defun id2sn (id)
  "relations for that id"
  (sn-p (explode- (txt id))))
